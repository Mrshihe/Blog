#### URL指的是统一资源定位符 URI指的是统一资源标识符 URL是URI的子集
##### URI格式
```
http://user:pass@www.example.com:80/html/demo.html?userId=1#flag

http:// --> 协议名
user:pass@ --> 登录信息(不推荐，不安全)
www.example.com --> 服务器地址<1.域名形式 2.192.168.0.1 IPV4形式 3.[0:0:0:0:0:0:1]IPV6形式>
:80 --> 端口号, http默认端口号80 https默认端口号443 默认端口号可省略
/html/demo.html --> 服务器文件路径
?userId=1 --> 查询字符串
#flag --> 片段标识符，表示文件中的某一位置(锚点定位)
```

#### TCP/IP协议簇
计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）；协议中存在各式各样的内容，从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤，这些协议的集合称之为TCP/IP协议簇

#### TCP/IP模型分层
```
1.应用层:
  应用层决定了向用户提供应用服务时通信的活动;该层常见协议：FTP、DNS、HTTP
2.传输层:
  传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输；该层协议：TCP、UDP
3.网络层:
  网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。网络层所起的作用就是在众多的选项内选择一条传输路线。
4.数据链路层:
  用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。
```
利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，每经过一层添加一个对应首部，接收端则从数据链路层往上走，每经过一层删除一个对应首部；
```
发送端：
应用层发出HTTP数据，到达传输层添加TCP首部，到达网络层添加IP首部，到达数据链路层添加以太网首部
```

#### 
#### HTTP(Hyper Text Transfer Protocol)超文本传输协议，无状态的应用层的协议。端口默认 80
HTTP1.1默认开启持久化连接(Connection:keep-alive),减少TCP连接的重复建立和断开连接造成的额外开销，减轻服务器压力

#### HTTP有两种报文，请求报文和响应报文；报文又可细分为如下：
```
起始行（start line）有以下两种类型。
  请求行：请求的方法、请求的 URL、HTTP的版本
  响应行：HTTP 版本、状态码
头部字段（header）：一些头部信息，以key: value的形式。
// 以空行分开报文头和报文体
主体（body）：被发送的数据
```
#### HTTP请求方法
```
GET：获取服务器资源。
POST：提交信息给服务器。
PUT：传输文件。
HEAD：和GET方法一样,但是只返回响应头部,作用是确定URL的有效性和资源更新的时间。
DELETE：删除指定的资源。
OPTIONS：查询请求服务器指定的资源所支持的方法。
TRACE：用来确认连接过程中发生的一些操作。
CONNECT：建立连接渠道，用于代理服务器。
```
#### HTTP响应状态码
```
1xx
  1XX表示接收的请求正在处理。
2xx 成功
  200 OK：表示客户端发送的请求在服务器端被正常处理了。
  204 No Content：表示请求被处理成功，但没有资源可返回。
  206 Partial Content：表示客户端只获取文件的一部分内容，而服务器成功执行了这部分的GET请求。响应报文中含Content-Range指定部分的实体内容。
3xx 重定向
  301 Moved Permanenty：永久重定向。表示请求的资源已经被分配了新的URL，以后就使用资源现在所指的URL。
  302 Found：临时重定向。表示请求的资源被分配了新的URL。
  303 See Other：表示请求的资源存着另一个URL，应该用GET方法获取请求的资源。
  304 Not Modified：表示请求已经找到，但不符合条件请求。协商缓存就会返回这个状态码。
  307 Temporary Redirect：临时重定向，和302类似。但是不会改变请求方法。
4xx 客户端错误
  400 Bad Request：表示请求报文中存在语法错误。
  401 Unauthorized：表示发送的请求要通过 HTTP 认证的认证消息。如果之前请求过一次，就表示用户认证失败。
  403 Forbidden：表示对请求资源的访问被服务器拒绝。
  404 Not Found：表示服务器上无法找到请求的资源。
5xx 服务器错误
  500 Internal Serve Error：表示服务器端在执行请求时发生错误。
  503 Service Unavailable：表示服务器暂处于超负荷或者正在进行停机维护。
  504 Gateway Timeout：表示服务器未能及时得到响应。
```

#### HTTP通用首部字段
```
1. Cache-Control 表示资源缓存操作，可为多个参数，以,分割
  请求头中:
    (1) no-store：不使用任何缓存，每次都向源服务器获取最新的资源
    (2) no-cache: 强制向源服务器再次验证缓存的资源是否过期
    (3) max-age: 缓存时间是距离发起的时间的秒数，超过间隔的秒数缓存失效
  响应头中：
    (1) public: 资源可被浏览器和代理服务器进行缓存
    (2) private: 资源只可以被浏览器进行缓存
    (3) no-cache: 缓存前必须验证其有效性
    (4) max-age: 设置缓存时间，如果没超过该时间，不用向服务器请求资源
2. Connection 管理持久连接
3. Date HTTP报文创建的时间和日期
4. Via 跟踪客户端和服务器端之间的请求和响应报文的传输路径
```

#### HTTP常用请求头字段
```
Host: www.baidu.com
客户端请求的资源所处的主机名和端口号
Referer: https://www.baidu.com/s?ie=UTF-8&wd=%E5%
客户端请求的原始资源的URI
Cookie: BIDUPSID=0FA3B0B34EA21368F4EC83116E240288;
服务器设置得Cookie信息
Accept: application/json, text/javascript, */*; q=0.01
客户端能够处理的媒体类型及媒体类型的相对优先级;优先级用q=表示,范围0~1,可精确到小数点后3位,默认为最大值1
Accept-Encoding: gzip, deflate
客户端支持的内容编码及内容编码的优先级顺序(采用权重q值来表示相对优先级)
Accept-Language: zh-CN,zh;q=0.9
客户端能够处理的自然语言集
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36
客户端使用的操作系统和浏览器的名称和版本

```
#### HTTP常用响应头字段
```
Allow：GET, POST
服务器支持哪些请求方法
Content-Encoding: gzip
服务器对实体的主体部分选用的内容编码方式
Content-Length: 78
响应体部分的大小(单位是字节)
Set-Cookie: PSINO=2; domain=.baidu.com; path=/
服务器端设置Cookie
Access-Control-Allow-Origin: * 
指定哪些站点可以参与跨站资源共享
```

### HTTP缓存，分为强缓存、协商缓存两种
加快资源获取速度, 减少网络传输, 缓解服务端压力

#### 强缓存
强缓存由Expires、Cache-Control 、Pragma3个Header属性共同控制
1. Expires:值为一个HTTP日期(优先级最低)
浏览器发起请求时，根据系统时间和Expires进行比较，如果系统时间超过Expires，缓存失效。（当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题)

2. Cache-Control:(HTTP/1.1新增)
常用的属性值:
```
max-age: 单位秒，缓存时间是距离发起的时间的秒数，超过间隔的秒数缓存失效
no-cache：不使用强缓存
no-store：禁止使用缓存(包括协商缓存)
private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应
public：响应可以被中间代理、CDN 等缓存
must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证
```

3. Pragma:no-cache 不使用强缓存,(优先级最高)


#### 协商缓存
浏览器的强缓存失效或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since或者If-None-Match的时候，会用这两个属性去验证是否命中协商缓存

1. ETag / If-None-Match
ETag/If-None-Match 的值是一串hash码(资源的标识符)，服务端的文件变化的时候hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的hash值进行比较，如果相等则表示命中协商缓存。
ETag 又有强弱校验之分，如果 hash 码是以 "W/" 开头的一串字符串，说明此时协商缓存的校验是弱校验。只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源。

2. Last-Modified / If-Modified-Since
Last-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间
并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较。

##### Last-Modified / If-Modified-Since以下情况并不准确
- 文件的修改频率在秒级以下，会错误地返回 304
- 文件被修改了，但是内容没有任何变化的时候, 会错误地返回 304


#### HTTP缺点
1. 通信使用明文（不加密），内容可能会被窃听
2. 无法证明报文的完整性，所以有可能已遭篡改
3. 不验证通信方的身份，因此有可能遭遇伪装（中间人攻击 Man-in-the-Middle attack MITM）

#### HTTPS = HTTP + SSL(Secure Socket Layer，安全套接层)/TLS(Transport Layer Security，安全传输层协议) 端口默认 443
HTTPS主要特点：
1. 内容加密
2. 身份认证
3. 数据完整性

#### HTTPS连接过程
1. 客服端发起HTTPS连接，携带自己支持的加密协议和SSL版本信息
2. 服务端选择合适的加密协议
3. 服务端发送数字证书，包括版本信息、序列号、颁发机构、有效期、公开密钥、签名算法、签名hash算法等
4. 客户端验证证书有效性，如证书有效，则生成一段随机数，用公钥进行加密，同时用签名hash算法得到握手信息的hash值，然后用生成的随机数对握手信息和握手信息hash值进行加密，返给服务端。
5. 服务端获取加密随机数后，用私钥解密，得到随机数，并验证握手信息是否被修改
6. 服务端使用获取到的随机数对握手信息和握手信息的hash值进行对称加密，发给客户端
7. 客服端用生成的随机值解密数据，验证握手信息，确认无误后开始用随机值对称加密内容进行通信
```
对称加密： 加密的密钥和解密的密钥相同
非对称加密： 密钥分为公钥和私钥,公钥可以公开,私钥需要保密,客户端公钥加密的数据,服务端可以通过私钥来解密
```

#### HTTP2.0
```
1. 二进制分帧
HTTP 2.0 把所有传输的信息分割成更小的消息和帧，并对它们采用二进制的格式编码
2. 首部压缩
在HTTP2.0中，使用了HPACK压缩格式对传输的头部进行编码，减少了头部的大小
3. 多路复用
TCP连接一旦建立可以并行发送请求
4. 请求优先级
把HTTP消息分解成多个独立的帧后，就可以通过优化这些帧的交错和传输顺序进一步性能优化
5. 服务器推送
服务器可以对一个客户端请求发送多个响应,服务器主动返回资源给客户端用户
```